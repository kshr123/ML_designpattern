# 機械学習システムデザインパターン学習プロジェクト - Claude Rules

## 📋 プロジェクト概要

このプロジェクトは『AIエンジニアのための機械学習システムデザインパターン』の学習と実践を目的としています。
参考リポジトリを基に、AI駆動開発でゼロから機械学習システムを実装します。

---

## 🎯 プロジェクトの目的

1. 機械学習システムの各種デザインパターンを理解する
2. 参考コードを分析し、設計思想を学ぶ
3. 学んだパターンをゼロから実装して実践的スキルを習得する
4. 学習過程を記録し、知識を体系化する

---

## 📁 ディレクトリ構造とルール

### ディレクトリの役割

```
.
├── reference/              # 参考リポジトリ（読み取り専用）
├── my_implementations/     # 自分で実装するコード（書き込み可）
├── notes/                  # 学習ノート・メモ（書き込み可）
└── progress/               # 進捗管理（書き込み可）
```

### 重要なルール

1. **`reference/` は読み取り専用**
   - 参考リポジトリのコードは変更しない
   - 分析や理解のためにのみ参照する
   - 必要に応じてコピーして `my_implementations/` で改変

2. **`my_implementations/` に実装する**
   - ゼロから実装したコードはここに配置
   - パターンごとにサブディレクトリを作成
   - 命名規則: `{NN}_{pattern_name}/` (例: `01_model_db/`, `02_iris_sklearn_svc/`)
   - **連番の接頭辞**: フロー順に理解できるように連番（01, 02, 03...）を接頭辞として付ける

3. **`notes/` に学習メモを記録**
   - パターンごとの理解をまとめる
   - アーキテクチャ図や設計メモを保存
   - 命名規則: `{pattern_name}_notes.md`

4. **`progress/` で進捗を管理**
   - `learning_log.md` は**進捗の把握のみに使用**
     - どこまで完了したか（チェックリスト）
     - 次にどこから始めるか（次のタスク）
   - **詳細な内容は各ディレクトリのREADMEで確認する**
     - 実装の詳細、技術スタック、学習内容は各パターンのREADME.mdに記載
     - learning_log.mdには詳細を書かず、完了日とステータスのみ記録

---

## 💻 コーディング規約

### Python

- **バージョン**: Python 3.13以上（最新の安定版を使用）
- **パッケージマネージャー**: uv（高速・モダンなパッケージマネージャー）
- **スタイル**: PEP 8に準拠
- **型ヒント**: 可能な限り使用する
- **docstring**: 重要な関数・クラスには必須
- **命名規則**:
  - 関数/変数: `snake_case`
  - クラス: `PascalCase`
  - 定数: `UPPER_CASE`

#### uvの使い方

```bash
# プロジェクトの初期化
uv init

# 依存関係のインストール
uv pip install <package>

# 仮想環境の作成と有効化
uv venv
source .venv/bin/activate  # macOS/Linux

# pyproject.tomlから依存関係をインストール
uv pip install -r pyproject.toml

# 依存関係のロック
uv pip freeze > requirements.txt
```

### Docker

- **ベースイメージ**: 公式イメージを使用
- **マルチステージビルド**: 可能な限り使用してイメージサイズを削減
- **環境変数**: センシティブな情報は`.env`ファイルで管理（gitignore必須）
- **.dockerignore**: 不要なファイルをコンテナに含めない

### ファイル構成

各実装には以下を含める：

#### 必須ファイル
- `SPECIFICATION.md` - **仕様書**（要件、アーキテクチャ、API設計）
- `README.md` - 実装の説明、セットアップ手順、実行方法
- `pyproject.toml` - プロジェクトメタデータと依存関係（uvで管理）
- `tests/` - テストコード（テスト駆動開発）
  - `test_unit.py` - ユニットテスト
  - `test_integration.py` - 統合テスト
  - `test_e2e.py` - E2Eテスト（必要に応じて）

#### 自動生成ファイル
- `uv.lock` - 依存関係のロックファイル（uvが自動生成）

#### オプションファイル
- `.python-version` - Pythonバージョンの指定
- `docker-compose.yml` - Docker環境
- `Makefile` - よく使うコマンドのショートカット
- `.env.example` - 環境変数のサンプル

---

## 📝 開発プロセス（仕様駆動 + テスト駆動）

このプロジェクトでは、実践に近い形で**仕様駆動開発（SDD）**と**テスト駆動開発（TDD）**を組み合わせて進めます。

### 開発フロー（全7フェーズ）

#### 1. **理解フェーズ** 📖
   - `reference/` の該当パターンのコードを読む
   - アーキテクチャ、データフロー、依存関係を理解する
   - ビジネス要件と技術的課題を把握する
   - `notes/` にメモを作成

#### 2. **仕様策定フェーズ** 📋 ← **仕様駆動開発**
   - `SPECIFICATION.md` を作成する
   - 以下を明確に定義：
     - **要件定義**: 機能要件と非機能要件
     - **アーキテクチャ設計**: システム構成、コンポーネント設計
     - **API仕様**: エンドポイント、入出力形式、エラーレスポンス
     - **データモデル**: データ構造、スキーマ
     - **成功基準**: 何を持って完成とするか
   - 仕様をClaude Codeとレビュー・議論する

#### 3. **テスト設計フェーズ** 🧪 ← **テスト駆動開発（Red）**
   - 仕様に基づいてテストケースを作成
   - テストの種類：
     - **ユニットテスト**: 個々の関数・クラスのテスト
     - **統合テスト**: コンポーネント間の連携テスト
     - **E2Eテスト**: システム全体の動作テスト
   - まず失敗するテストを書く（Red）
   - `pytest` で実行してテストが失敗することを確認
   - **テスト結果を保存**: `pytest tests/test_{module}.py -v > test_results/{module}_red.txt 2>&1`
   - ファイルを編集してヘッダーと分析を追加

#### 4. **実装フェーズ** 💻 ← **テスト駆動開発（Green）**
   - `my_implementations/` にゼロから実装
   - テストを通すための最小限の実装から始める
   - 段階的に機能を拡張
   - 各ステップでテストを実行してGreenにする
   - コードはシンプルから始めて段階的に拡張
   - 参考コードは見てもよいが、コピペはしない
   - **テスト結果を保存**: `pytest tests/test_{module}.py -v --cov=src --cov-report=html > test_results/{module}_green.txt 2>&1`
   - ファイルを編集してヘッダーと分析を追加
   - **Red/Green比較**: test_results/{module}_red.txt と test_results/{module}_green.txt で進捗を確認

#### 5. **リファクタリングフェーズ** ♻️ ← **テスト駆動開発（Refactor）**
   - テストが通った状態でコードを改善
   - 以下を意識：
     - コードの可読性向上
     - 重複の削除（DRY原則）
     - 適切な抽象化
     - パフォーマンス最適化
   - リファクタリング後もテストがGreenであることを確認

#### 6. **検証フェーズ** ✅
   - 実装したコードを実際に動かして確認
   - ログやメトリクスを確認
   - 仕様書の成功基準を満たしているか検証
   - エッジケースやエラーハンドリングの確認
   - 負荷テスト（必要に応じて）

#### 7. **振り返りフェーズ** 📊
   - **ドキュメント更新（必須）**
     1. パターンディレクトリの `README.md` を更新（詳細な学習内容を記載）
     2. チャプターディレクトリの `README.md` を更新（そのチャプターの進捗を反映）
     3. プロジェクトルートの `README.md` を更新（全体の進捗を反映）
     4. `progress/learning_log.md` に完了日とステータスを記録（詳細は書かない）
   - **学習内容の整理**
     - 学んだこと、疑問点、改善点をパターンのREADMEにまとめる
     - 仕様と実装のギャップを分析
     - 次のパターンへの接続を考える
   - **コードレビュー**（自己レビュー）を実施
   - **Git操作**
     - 変更をコミット
     - プッシュ（Claude Codeは実行前に必ず確認を取る）

### TDDサイクル（Red-Green-Refactor）

```
┌─────────────────────────────────────┐
│  1. 仕様を書く（SPECIFICATION.md） │
└──────────────┬──────────────────────┘
               ↓
┌──────────────────────────────────────┐
│  2. テストを書く（失敗するテスト）  │ ← Red
└──────────────┬───────────────────────┘
               ↓
┌──────────────────────────────────┐
│  3. 実装する（テストを通す）    │ ← Green
└──────────────┬───────────────────┘
               ↓
┌──────────────────────────────┐
│  4. リファクタリングする    │ ← Refactor
└──────────────┬───────────────┘
               ↓
      テストが通っているか？
               ↓
          [次の機能へ]
```

### ドキュメント記載内容

#### SPECIFICATION.md（仕様書）

```markdown
# {パターン名} 仕様書

## 1. 要件定義

### 1.1 機能要件
- [ ] 要件1
- [ ] 要件2

### 1.2 非機能要件
- **パフォーマンス**: レスポンスタイム < 100ms
- **スケーラビリティ**: 同時接続数 > 100
- **可用性**: 99.9%以上
- **セキュリティ**: [セキュリティ要件]

## 2. アーキテクチャ設計

### 2.1 システム構成
[構成図またはテキストで説明]

### 2.2 コンポーネント設計
- **コンポーネントA**: 役割と責務
- **コンポーネントB**: 役割と責務

### 2.3 技術スタック
- Python 3.13
- [使用するライブラリ]

## 3. API仕様

### 3.1 エンドポイント
| Method | Path | Description |
|--------|------|-------------|
| POST   | /predict | 推論実行 |

### 3.2 リクエスト/レスポンス形式
[詳細なスキーマ]

### 3.3 エラーレスポンス
[エラーコードとメッセージ]

## 4. データモデル

### 4.1 入力データ
[スキーマ定義]

### 4.2 出力データ
[スキーマ定義]

## 5. 成功基準

- [ ] 全テストケースがパス
- [ ] パフォーマンス要件を満たす
- [ ] エラーハンドリングが適切
- [ ] ログが適切に出力される
```

#### README.md（実装ドキュメント）

```markdown
# {パターン名}

## 概要
このパターンの目的と解決する課題

## アーキテクチャ
システム構成図や説明

## セットアップ
環境構築手順

## 実行方法
実際の実行コマンドとその説明

## テスト
テストの実行方法

## 学んだこと
実装を通して得た知見

## 参考
- [SPECIFICATION.md](./SPECIFICATION.md)
- [元のコード](../../../reference/...)
```

---

## 🔧 実装時の注意事項

### セキュリティ

- **機密情報**: API キー、パスワード等は環境変数で管理
- **`.gitignore`**: `.env`, `*.pem`, `*.key` 等を必ず追加
- **依存関係**: セキュリティ脆弱性のあるパッケージを避ける
- **入力検証**: 外部からの入力は必ず検証・サニタイズ

### パフォーマンス

- **リソース管理**: メモリリーク、ファイルディスクリプタのクローズ漏れに注意
- **非同期処理**: I/Oバウンドな処理は非同期化を検討
- **バッチサイズ**: メモリを考慮した適切なバッチサイズを設定
- **キャッシュ**: 計算コストの高い処理は適切にキャッシュ

### 機械学習特有の注意点

- **モデル管理**: モデルファイルのバージョン管理（DVC等の利用を検討）
- **再現性**: random seedの固定、環境の明示
- **データ**: サンプルデータはgitにコミットせず、ダウンロードスクリプトを用意
- **評価**: 学習と推論のメトリクスを明確に記録

### テスト結果の管理

TDDサイクル（Red→Green）の証跡を残すため、テスト結果を適切に管理します。

#### テスト結果とコード品質チェック結果の取り扱い

**重要**: テスト結果とコード品質チェック結果は **Gitで管理しません**。

**理由**:
- 実行環境やタイミングで結果が変わる
- ローカル環境固有の情報を含む可能性がある
- CI/CDで自動生成されるべき
- 容量が大きくなる可能性がある

#### Git管理しないファイル ❌
- `tests/test_results/` - テスト結果（再生成可能）
- `quality_checks/` - コード品質チェック結果（再生成可能）
- `htmlcov/` - HTMLカバレッジレポート（再生成可能）
- `.pytest_cache/` - pytestキャッシュ
- `.coverage` - カバレッジデータ（バイナリ）
- `mlruns/` - MLflow実験データ（ローカル環境固有）

#### ローカルで結果を確認する方法

テスト結果やコード品質チェック結果は、各開発者がローカル環境で生成して確認します：

```bash
# テスト結果を生成
mkdir -p tests/test_results
pytest tests/ -v > tests/test_results/full_test_results.txt 2>&1

# コード品質チェック結果を生成
mkdir -p quality_checks
black --check src/ tests/ > quality_checks/black_results.txt 2>&1
ruff check src/ tests/ > quality_checks/ruff_results.txt 2>&1
mypy src/ > quality_checks/mypy_results.txt 2>&1
```

#### README.mdは Git管理する ✅

ただし、以下のREADMEファイルは**Git管理します**（結果ファイル自体は管理しない）：
- `tests/test_results/README.md` - pytest出力の読み方ガイド
- `quality_checks/README.md` - コード品質チェック結果の読み方ガイド

**理由**:
- 初見の人がテスト結果や品質チェック結果を理解するために必要
- 環境に依存しない一般的な情報
- プロジェクトのドキュメントとして価値がある

#### ファイル形式の推奨事項

テスト結果ファイルには、**ヘッダーと分析セクション**を含めることを推奨します。これにより、初見の人でもpytestの出力を理解しやすくなります。

**tests/test_results/README.md の形式**（必須）:
```markdown
# テスト結果の読み方

このディレクトリにはpytestの実行結果が保存されています。

## 📖 pytest出力の読み方

### テスト実行結果の見方

\`\`\`
tests/test_01_data_loader.py::TestDataLoader::test_load_data_setosa PASSED [  2%]
                              ↑                ↑                      ↑       ↑
                           ファイル名       クラス名              テスト名  結果  進捗
\`\`\`

### 結果の種類

- **PASSED** ✅ - テスト成功
- **FAILED** ❌ - テスト失敗
- **SKIPPED** ⏭️ - テストスキップ
- **ERROR** 💥 - テスト実行時エラー

### サマリー

\`\`\`
======================== 1 failed, 33 passed in 27.77s =========================
                         ↑        ↑             ↑
                      失敗数    成功数      実行時間
\`\`\`

[その他の説明...]
```

**full_test_results.txt の形式**:
```
################################################################################
# pytest 全テスト実行結果
################################################################################
#
# 実行日時: 2025-11-05 09:41
# 実行コマンド: pytest tests/ -v
# Python: 3.13.9
# pytest: 8.4.2
#
# このファイルの読み方は tests/test_results/README.md を参照してください
#
################################################################################

[pytest出力]

################################################################################
# テスト結果サマリー
################################################################################
#
# 総テスト数: 34
# 成功: 33 (97.1%)
# 失敗: 1 (2.9%)
# 実行時間: 27.77秒
#
# 【成功したテストモジュール】
# ✅ test_01_data_loader.py    - 8/8 passed
# ✅ test_02_model.py           - 5/5 passed
# ...
#
# 【失敗したテスト】
# ❌ test_05_mlflow_manager.py::test_log_model
#    原因: [説明]
#    影響: [実用上の影響]
#
################################################################################
```

**{module}_red.txt の形式**（TDD Red Phase）:
```
################################################################################
# TDD Red Phase - テスト結果（失敗フェーズ）
################################################################################
#
# 目的: テストを先に書き、実装がない状態で失敗することを確認する
# 状態: ❌ FAILED - 期待通りの失敗
# 実行日時: [実装前の日時]
#
################################################################################

[pytest出力]

################################################################################
# Red Phase 分析
################################################################################
#
# エラー内容: [エラーの説明]
# これは正しいTDDの流れ: [説明]
# 次のステップ: [次にすべきこと]
#
################################################################################
```

**{module}_green.txt の形式**（TDD Green Phase）:
```
################################################################################
# TDD Green Phase - テスト結果（成功フェーズ）
################################################################################
#
# 目的: 実装を完了し、全てのテストが通ることを確認する
# 状態: ✅ PASSED - 全テスト成功
# 実行日時: [実装後の日時]
# コマンド: pytest tests/ -v --cov=src --cov-report=html
#
################################################################################

[pytest出力]

################################################################################
# Green Phase 分析
################################################################################
#
# テスト結果サマリー:
#   ✅ 全Nテストケースが成功（PASSED）
#   ✅ コードカバレッジ: N%
#   ✅ 実行時間: N秒
#
# 成功したテストケース:
#   1. test_xxx - [説明]
#   2. test_yyy - [説明]
#
# TDDサイクル完了:
#   Red（失敗）→ Green（成功）→ 次はRefactor（リファクタリング）
#
################################################################################
```

**ディレクトリ構造**:
```
project_root/
├── tests/
│   ├── test_results/           # テスト結果を集約（testsディレクトリ内）
│   │   ├── README.md           # pytest出力の読み方（必須）
│   │   ├── full_test_results.txt  # 全テスト結果
│   │   ├── data_loader_red.txt    # TDD Red
│   │   ├── data_loader_green.txt  # TDD Green
│   │   └── ...
│   ├── test_01_data_loader.py
│   ├── test_02_model.py
│   └── ...
├── src/
└── ...
```

**保存コマンド**:
```bash
# testsディレクトリ内にtest_resultsを作成
mkdir -p tests/test_results

# README.mdを作成（pytest出力の読み方）
# [テンプレートを使用]

# 全テスト実行結果を保存（ヘッダー付き）
pytest tests/ -v > tests/test_results/full_test_results.txt 2>&1
# ファイルを編集してヘッダーと分析を追加

# TDD Red: テストが失敗することを確認
pytest tests/test_{module}.py -v > tests/test_results/{module}_red.txt 2>&1
# ファイルを編集してヘッダーと分析を追加

# TDD Green: テストが成功することを確認
pytest tests/test_{module}.py -v --cov=src --cov-report=html > tests/test_results/{module}_green.txt 2>&1
# ファイルを編集してヘッダーと分析を追加
```

この形式により、後から見返したときにTDDのプロセスを理解しやすくなり、初見の人でもpytestの出力を読めるようになります。

---

## 🚀 開発ワークフロー

### 新しいパターンを実装する場合（仕様駆動 + TDD）

#### Step 1: プロジェクトセットアップ

```bash
# 1. ディレクトリを作成
mkdir -p my_implementations/ch{N}__{pattern_name}
cd my_implementations/ch{N}__{pattern_name}

# 2. テンプレートからpyproject.tomlをコピー
cp ../../templates/pyproject.toml.template pyproject.toml

# 3. Pythonバージョンを指定
echo "3.13" > .python-version

# 4. 仮想環境の作成
uv venv

# 5. 仮想環境の有効化
source .venv/bin/activate

# 6. 開発ツールのインストール
uv pip install pytest pytest-cov black ruff mypy

# 7. ディレクトリ構造を作成
mkdir -p tests src/{pattern_name}
touch src/{pattern_name}/__init__.py
touch tests/__init__.py
```

#### Step 2: 仕様策定（SDD）

```bash
# SPECIFICATION.mdを作成
# Claude Codeに「{パターン名}の仕様書を作成して」と依頼
```

仕様書には以下を含める：
- 要件定義（機能要件・非機能要件）
- アーキテクチャ設計
- API仕様
- データモデル
- 成功基準

#### Step 3: テスト作成（TDD - Red）

```bash
# テストファイルを作成
# Claude Codeに「仕様書に基づいてテストを作成して」と依頼
```

テストは仕様に基づいて作成：
- `tests/test_unit.py` - ユニットテスト
- `tests/test_integration.py` - 統合テスト
- `tests/test_e2e.py` - E2Eテスト（必要に応じて）

テストを実行して失敗することを確認：
```bash
pytest tests/ -v
# → テストが失敗する（Red）
```

#### Step 4: 実装（TDD - Green）

```bash
# Claude Codeに「テストを通すための実装を段階的に進めて」と依頼
```

最小限の実装から始めて、徐々に機能を追加：
1. 最初のテストを通す
2. 次のテストを通す
3. 繰り返し

各ステップでテストを実行：
```bash
pytest tests/ -v
# → テストが通る（Green）
```

#### Step 5: リファクタリング（TDD - Refactor）

```bash
# Claude Codeに「コードをレビューしてリファクタリング提案をして」と依頼
```

改善項目：
- コードの可読性
- 重複の削除
- 適切な抽象化
- パフォーマンス最適化

リファクタリング後にテストを実行：
```bash
pytest tests/ -v --cov=src
# → テストが通り、カバレッジを確認
```

#### Step 6: コード品質チェック

コード品質チェックを実行し、結果を保存します。

```bash
# 品質チェック用ディレクトリを作成
mkdir -p quality_checks

# Black（コードフォーマット）
black --check src/ tests/ > quality_checks/black_results.txt 2>&1
# ファイルを編集してヘッダーと分析を追加

# Ruff（リント）
ruff check src/ tests/ > quality_checks/ruff_results.txt 2>&1
# ファイルを編集してヘッダーと分析を追加

# Mypy（型チェック）
mypy src/ > quality_checks/mypy_results.txt 2>&1
# ファイルを編集してヘッダーと分析を追加

# テスト実行（カバレッジ付き）
pytest tests/ -v --cov=src --cov-report=html
```

**コード品質チェック結果の管理**:

結果ファイルには**ヘッダーと分析セクション**を含めること：

```
################################################################################
# Black コードフォーマットチェック結果
################################################################################
#
# 実行日時: 2025-11-05
# 実行コマンド: black --check src/ tests/
# Black バージョン: 24.10.0
#
# このファイルの読み方は quality_checks/README.md を参照してください
#
################################################################################

[ツールの出力]

################################################################################
# 結果サマリー
################################################################################
#
# ステータス: ✅ PASS
# チェック対象: Nファイル
# 問題のあるファイル: 0ファイル
#
# 【評価】
# ✅ すべてのファイルが規約に準拠しています
# ...
#
################################################################################
```

**quality_checks/README.md** を作成して、各ツールの出力の読み方を説明すること：
- Black: フォーマットチェック結果の読み方
- Ruff: リント結果とエラーの種類
- Mypy: 型エラーと警告の読み方（外部ライブラリのスタブ不足は許容）

**ディレクトリ構造**:
```
project_root/
├── quality_checks/           # コード品質チェック結果
│   ├── README.md             # 各ツールの出力の読み方（必須）
│   ├── black_results.txt     # Blackの結果
│   ├── ruff_results.txt      # Ruffの結果
│   └── mypy_results.txt      # Mypyの結果
├── src/
└── tests/
```

#### Step 7: ドキュメント作成と記録（必須）

**重要**: チュートリアル完了後は、**必ずディレクトリ単位→プロジェクト単位でドキュメントを更新する**

```bash
# 1. パターンディレクトリのREADME.mdを作成/更新
# - 実装の詳細、技術スタック、学習内容を記載
# - 他の人が見てもわかるように丁寧に書く

# 2. チャプターディレクトリのREADME.mdを更新
# - そのチャプター内の進捗状況を更新
# - 完了したパターンの概要を追加

# 3. プロジェクトルートのREADME.mdを更新
# - 全体の完了パターン数を更新
# - 完了したパターンのリストを更新

# 4. progress/learning_log.mdを更新
# - 完了日とステータスのみ記録
# - 詳細は書かない（各READMEで確認できるため）
```

**更新の順序**:
1. パターンのREADME.md（詳細）
2. チャプターのREADME.md（そのチャプター内の進捗）
3. プロジェクトのREADME.md（全体の進捗）
4. progress/learning_log.md（進捗管理のみ）

### Claude Codeへの指示例

#### 良い指示（仕様駆動 + TDD）:

**フェーズ1: 理解**
- "synchronous_patternの参考コードを分析して、要件とアーキテクチャを説明して"
- "このパターンが解決する課題とユースケースを教えて"

**フェーズ2: 仕様策定**
- "同期推論パターンのSPECIFICATION.mdを作成して。要件定義から始めて"
- "API仕様を詳細に定義して。エンドポイント、入出力、エラーレスポンスを含めて"

**フェーズ3: テスト作成**
- "仕様書に基づいてユニットテストを作成して。まず失敗するテストから"
- "統合テストのテストケースを追加して"

**フェーズ4: 実装**
- "最初のテストを通すための最小限の実装をして"
- "次の機能を実装して、テストを段階的にGreenにして"

**フェーズ5: リファクタリング**
- "実装をレビューして、改善点を提案して"
- "パフォーマンスを最適化して、テストが通ることを確認して"

**フェーズ6: 検証**
- "実装したコードを実際に動かして動作確認して"
- "エラーケースのハンドリングを確認して"

#### 悪い指示：

- "参考コードをそのままコピーして" ← 学習にならない
- "全部一気に実装して" ← TDDサイクルを無視
- "テストは後で書く" ← テスト駆動開発ではない
- "仕様書は不要" ← 仕様駆動開発ではない

---

## 📊 進捗管理

### progress/learning_log.md の役割

**重要**: `progress/learning_log.md` は**進捗把握専用**です。詳細な内容は書きません。

**記載内容**:
- ✅ どこまで完了したか（チェックリスト）
- ✅ 次にどこから始めるか（次のタスク）
- ✅ 完了日のみ（例: `2025-11-05`）
- ❌ 学習内容の詳細（各READMEで確認）
- ❌ 実装の詳細（パターンのREADMEで確認）
- ❌ 技術スタック（パターンのREADMEで確認）

### ドキュメント更新フロー（必須）

**各チュートリアル完了後は必ず以下の順序でドキュメントを更新すること**:

1. **パターンのREADME.md**
   - 実装の詳細、技術スタック、学習内容を詳しく記載
   - 他の人が見てもわかるように丁寧に書く

2. **チャプターのREADME.md**
   - そのチャプター内の進捗状況を更新
   - 完了したパターンの概要を追加

3. **プロジェクトルートのREADME.md**
   - 全体の完了パターン数を更新
   - 完了したパターンのリストを更新

4. **progress/learning_log.md**
   - 完了日とステータスのみ記録
   - 詳細は書かない

### 必須タスク

- [ ] 各パターン学習開始時: `progress/learning_log.md` にチェックボックスを追加
- [ ] 実装完了時: **4段階のドキュメント更新**を実施
  1. パターンのREADME.md（詳細）
  2. チャプターのREADME.md（チャプター進捗）
  3. プロジェクトのREADME.md（全体進捗）
  4. learning_log.md（完了日のみ）
- [ ] Git操作: 変更をコミット・プッシュ

### 推奨タスク

- 重要な発見や気づきはパターンのREADMEに記載
- 躓いた点とその解決方法をパターンのREADMEに記録
- パターン間の関連性や組み合わせ方をチャプターのREADMEに記載

---

## 🎓 学習の優先順位

### 推奨学習順序

1. **Chapter 2: Training** - 基礎となるモデル学習
2. **Chapter 3: Release Patterns** - モデルのリリース方法
3. **Chapter 4: Serving Patterns** - 推論サービスの実装（最重要）
4. **Chapter 5: Operations** - 運用とモニタリング
5. **Chapter 6: Operation Management** - 高度な運用管理

ただし、興味のある分野から始めてもOK。モチベーション維持が最優先。

---

## 🤝 Claude Codeとの協働ルール

### Claude Code に期待すること

1. **コード分析**: 参考コードの詳細な説明
2. **設計支援**: アーキテクチャの提案と議論
3. **実装サポート**: ゼロからのコーディング支援
4. **レビュー**: 実装したコードの改善提案
5. **トラブルシューティング**: エラーの解決支援
6. **ドキュメント作成**: README等の作成補助

### Claude Code が守るべきこと

1. **仕様駆動**: まず仕様を明確にし、それに基づいて開発を進める
2. **テスト駆動**: テストを先に書き、Red→Green→Refactorのサイクルを守る
3. **段階的実装**: 一度に全てを実装せず、小さなステップで進める
4. **説明**: コードだけでなく、なぜそう実装するのか説明する
5. **選択肢の提示**: 複数のアプローチがある場合は選択肢を示す
6. **学習重視**: 単にコードを書くだけでなく、理解を深める支援をする
7. **ベストプラクティス**: 本番環境を想定した品質のコードを書く
8. **実践的**: エラーハンドリング、ログ、モニタリングを含める
9. **Git操作の確認**: `git push` は実行前に必ずユーザーの確認を取る
10. **ドキュメント更新**: 各チュートリアル完了後、**必ず4段階のドキュメント更新**を実施する
    - パターンのREADME.md → チャプターのREADME.md → プロジェクトのREADME.md → learning_log.md
11. **命名規則**: 実装ファイルには連番を接頭辞として付ける（01_, 02_, 03_...）

---

## 🔌 外部ツール連携

このプロジェクトでは、以下の外部ツールをMCP (Model Context Protocol) 経由で利用できます：

- **GitHub MCP**: リポジトリ操作、Issue/PR管理
- **Notion MCP**: 学習記録の管理
- **Serena MCP**: 高度なコード分析・編集
- **Context7 MCP**: 最新ライブラリドキュメントの参照
- **PostgreSQL MCP**: データベース操作

詳細な設定方法は `notes/mcp_setup_guide.md` を参照してください。

---

## 📝 一時ファイルの管理ルール

### セッション関連の一時ファイル

プロジェクト進行中に作成される一時的なファイルは、セッション終了後に削除するかgitignoreに追加してください。

#### 一時ファイルの種類

1. **セッション記録ファイル**
   - `SESSION_*.txt` - セッション固有の作業記録
   - `PROJECT_STATUS.md` - その時点のプロジェクト状態
   - `QUICKSTART.md` - セッション固有のクイックスタートガイド
   - `RESTART_*.md` - セッション固有の再開手順

2. **一時的なガイドファイル**
   - セッション固有の手順書
   - 特定の問題解決のための一時ドキュメント

#### 管理方針

- **セッション終了時**: 一時ファイルを削除または整理
- **永続的な情報**: `notes/` または `progress/` に統合
- **.gitignore**: 一時ファイルのパターンを追加

```gitignore
# Session files (may contain tokens)
SESSION_*.txt
PROJECT_STATUS.md
QUICKSTART.md
RESTART_*.md
```

#### 判断基準

| ファイル | 保持 | 理由 |
|---------|------|------|
| 学習ガイド（汎用的） | ✅ | 今後も参照価値がある |
| セッション手順書 | ❌ | その時点の状況に特化 |
| 技術ドキュメント | ✅ | 永続的な知識 |
| ステータスファイル | ❌ | 時間経過で陳腐化 |

---

## 🔒 個人情報とセキュリティルール

### 個人情報の取り扱い

このプロジェクトは公開リポジトリとして運用されるため、個人情報の管理を徹底してください。

#### 禁止事項

以下の個人情報をコード、ドキュメント、コミットメッセージに含めないでください：

1. **実名**
   - フルネーム
   - 名前の一部（ファーストネーム、ラストネーム）

2. **連絡先情報**
   - メールアドレス（プライベート）
   - 電話番号
   - 住所

3. **システム固有情報**
   - ローカルマシンのユーザー名
   - ホスト名
   - 絶対パスに含まれる個人名

#### 推奨事項

**GitHubユーザー名を使用**:
- ドキュメントの作者名: `kshr123`
- Gitコミット設定:
  ```bash
  git config --global user.name "kshr123"
  git config --global user.email "kshr123@users.noreply.github.com"
  ```

**パス表記**:
```bash
# ❌ 個人情報を含む
/Users/tanaka_taro/Desktop/dev/ML_designpattern

# ✅ プレースホルダーを使用
/Users/kshr123/Desktop/dev/ML_designpattern
# または
/path/to/ML_designpattern
# または
~/Desktop/dev/ML_designpattern
```

**ドキュメントのメタデータ**:
```markdown
# ❌ 実名を含む
Author: Tanaka Taro
開発者: 田中太郎

# ✅ GitHubユーザー名を使用
Author: kshr123
開発者: kshr123
```

### 機密情報の取り扱い

#### 管理が必要な情報

1. **APIキー・トークン**
   - GitHub Personal Access Token
   - Notion Integration Token
   - その他のAPI認証情報

2. **環境変数**
   - データベース接続情報
   - サービスの認証情報

3. **秘密鍵**
   - SSH秘密鍵
   - 暗号化キー
   - 証明書

#### 安全な管理方法

**環境変数ファイル**:
```bash
# .env ファイルを使用（gitignore必須）
GITHUB_TOKEN=your_token_here
NOTION_TOKEN=your_notion_token
DATABASE_URL=postgresql://user:pass@localhost/db
```

**サンプルファイルの提供**:
```bash
# .env.example をリポジトリにコミット
GITHUB_TOKEN=your_token_here
NOTION_TOKEN=your_notion_token
DATABASE_URL=postgresql://localhost/postgres
```

**.gitignoreの設定**:
```gitignore
# Secrets
*.pem
*.key
credentials.json
secrets.yaml

# MCP Configuration (contains API tokens)
.mcp.json
.claude/settings.local.json

# Environment variables
.env
.env.local
.env.*.local
```

### Git履歴のクリーンアップ

もし個人情報や機密情報をコミットしてしまった場合：

**最新コミットのみの場合**:
```bash
# ファイルを削除してコミットを修正
git rm <sensitive-file>
git commit --amend --no-edit
git push --force
```

**履歴全体から削除する場合**:
```bash
# filter-branchで履歴を書き換え
git filter-branch --env-filter '
OLD_EMAIL="personal@email.com"
CORRECT_NAME="kshr123"
CORRECT_EMAIL="kshr123@users.noreply.github.com"

if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$CORRECT_NAME"
    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$CORRECT_NAME"
    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
fi
' --tag-name-filter cat -- --branches --tags

# 強制プッシュ
git push --force
```

**注意**: 強制プッシュは共同作業者に影響を与えるため、個人プロジェクトでのみ実施してください。

### GitHub Push Protectionについて

GitHubは自動的にトークンやシークレットの検出を行います：
- プッシュ時に機密情報を検出すると自動的にブロック
- 検出されたら該当ファイルを削除してから再プッシュ
- `.gitignore`を適切に設定して予防

---

## 🔄 このファイルの更新

このルールファイルは学習の進捗に応じて更新してください：
- 新しいベストプラクティスを発見したら追加
- 不要なルールは削除
- プロジェクトの方向性が変わったら反映

最終更新: 2025-11-05
- プロジェクト全体のルールと開発プロセスを整理
- 一時ファイル管理ルールを追加
- 個人情報とセキュリティルールを追加
- Git push前の確認ルールを追加
- MCP設定の詳細は notes/mcp_setup_guide.md に分離
- **命名規則を更新**: 連番接頭辞（01_, 02_, 03_...）でフロー順に整理
- **progress/learning_log.md の役割を明確化**: 進捗把握のみに使用、詳細は各READMEで確認
- **ドキュメント更新フローを必須化**: チュートリアル完了後は4段階でドキュメントを更新
  1. パターンのREADME.md（詳細）
  2. チャプターのREADME.md（チャプター進捗）
  3. プロジェクトのREADME.md（全体進捗）
  4. learning_log.md（完了日のみ）
