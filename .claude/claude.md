# 機械学習システムデザインパターン学習プロジェクト - Claude Rules

## 📋 プロジェクト概要

このプロジェクトは『AIエンジニアのための機械学習システムデザインパターン』の学習と実践を目的としています。
参考リポジトリを基に、AI駆動開発でゼロから機械学習システムを実装します。

---

## 🎯 プロジェクトの目的

1. 機械学習システムの各種デザインパターンを理解する
2. 参考コードを分析し、設計思想を学ぶ
3. 学んだパターンをゼロから実装して実践的スキルを習得する
4. 学習過程を記録し、知識を体系化する

---

## 📁 ディレクトリ構造とルール

### ディレクトリの役割

```
.
├── reference/              # 参考リポジトリ（読み取り専用）
├── my_implementations/     # 自分で実装するコード（書き込み可）
├── notes/                  # 学習ノート・メモ（書き込み可）
└── progress/               # 進捗管理（書き込み可）
```

### 重要なルール

1. **`reference/` は読み取り専用**
   - 参考リポジトリのコードは変更しない
   - 分析や理解のためにのみ参照する
   - 必要に応じてコピーして `my_implementations/` で改変

2. **`my_implementations/` に実装する**
   - ゼロから実装したコードはここに配置
   - パターンごとにサブディレクトリを作成
   - 命名規則: `{chapter}__{pattern_name}/` (例: `ch4__synchronous_pattern/`)

3. **`notes/` に学習メモを記録**
   - パターンごとの理解をまとめる
   - アーキテクチャ図や設計メモを保存
   - 命名規則: `{pattern_name}_notes.md`

4. **`progress/` で進捗を管理**
   - `learning_log.md` を常に最新に保つ
   - 各パターンの学習完了時にチェックを入れる

---

## 💻 コーディング規約

### Python

- **バージョン**: Python 3.13以上（最新の安定版を使用）
- **パッケージマネージャー**: uv（高速・モダンなパッケージマネージャー）
- **スタイル**: PEP 8に準拠
- **型ヒント**: 可能な限り使用する
- **docstring**: 重要な関数・クラスには必須
- **命名規則**:
  - 関数/変数: `snake_case`
  - クラス: `PascalCase`
  - 定数: `UPPER_CASE`

#### uvの使い方

```bash
# プロジェクトの初期化
uv init

# 依存関係のインストール
uv pip install <package>

# 仮想環境の作成と有効化
uv venv
source .venv/bin/activate  # macOS/Linux

# pyproject.tomlから依存関係をインストール
uv pip install -r pyproject.toml

# 依存関係のロック
uv pip freeze > requirements.txt
```

### Docker

- **ベースイメージ**: 公式イメージを使用
- **マルチステージビルド**: 可能な限り使用してイメージサイズを削減
- **環境変数**: センシティブな情報は`.env`ファイルで管理（gitignore必須）
- **.dockerignore**: 不要なファイルをコンテナに含めない

### ファイル構成

各実装には以下を含める：

#### 必須ファイル
- `SPECIFICATION.md` - **仕様書**（要件、アーキテクチャ、API設計）
- `README.md` - 実装の説明、セットアップ手順、実行方法
- `pyproject.toml` - プロジェクトメタデータと依存関係（uvで管理）
- `tests/` - テストコード（テスト駆動開発）
  - `test_unit.py` - ユニットテスト
  - `test_integration.py` - 統合テスト
  - `test_e2e.py` - E2Eテスト（必要に応じて）

#### 自動生成ファイル
- `uv.lock` - 依存関係のロックファイル（uvが自動生成）

#### オプションファイル
- `.python-version` - Pythonバージョンの指定
- `docker-compose.yml` - Docker環境
- `Makefile` - よく使うコマンドのショートカット
- `.env.example` - 環境変数のサンプル

---

## 📝 開発プロセス（仕様駆動 + テスト駆動）

このプロジェクトでは、実践に近い形で**仕様駆動開発（SDD）**と**テスト駆動開発（TDD）**を組み合わせて進めます。

### 開発フロー（全7フェーズ）

#### 1. **理解フェーズ** 📖
   - `reference/` の該当パターンのコードを読む
   - アーキテクチャ、データフロー、依存関係を理解する
   - ビジネス要件と技術的課題を把握する
   - `notes/` にメモを作成

#### 2. **仕様策定フェーズ** 📋 ← **仕様駆動開発**
   - `SPECIFICATION.md` を作成する
   - 以下を明確に定義：
     - **要件定義**: 機能要件と非機能要件
     - **アーキテクチャ設計**: システム構成、コンポーネント設計
     - **API仕様**: エンドポイント、入出力形式、エラーレスポンス
     - **データモデル**: データ構造、スキーマ
     - **成功基準**: 何を持って完成とするか
   - 仕様をClaude Codeとレビュー・議論する

#### 3. **テスト設計フェーズ** 🧪 ← **テスト駆動開発（Red）**
   - 仕様に基づいてテストケースを作成
   - テストの種類：
     - **ユニットテスト**: 個々の関数・クラスのテスト
     - **統合テスト**: コンポーネント間の連携テスト
     - **E2Eテスト**: システム全体の動作テスト
   - まず失敗するテストを書く（Red）
   - `pytest` で実行してテストが失敗することを確認

#### 4. **実装フェーズ** 💻 ← **テスト駆動開発（Green）**
   - `my_implementations/` にゼロから実装
   - テストを通すための最小限の実装から始める
   - 段階的に機能を拡張
   - 各ステップでテストを実行してGreenにする
   - コードはシンプルから始めて段階的に拡張
   - 参考コードは見てもよいが、コピペはしない

#### 5. **リファクタリングフェーズ** ♻️ ← **テスト駆動開発（Refactor）**
   - テストが通った状態でコードを改善
   - 以下を意識：
     - コードの可読性向上
     - 重複の削除（DRY原則）
     - 適切な抽象化
     - パフォーマンス最適化
   - リファクタリング後もテストがGreenであることを確認

#### 6. **検証フェーズ** ✅
   - 実装したコードを実際に動かして確認
   - ログやメトリクスを確認
   - 仕様書の成功基準を満たしているか検証
   - エッジケースやエラーハンドリングの確認
   - 負荷テスト（必要に応じて）

#### 7. **振り返りフェーズ** 📊
   - `progress/learning_log.md` に学習内容を記録
   - 学んだこと、疑問点、改善点をまとめる
   - 仕様と実装のギャップを分析
   - 次のパターンへの接続を考える
   - コードレビュー（自己レビュー）を実施

### TDDサイクル（Red-Green-Refactor）

```
┌─────────────────────────────────────┐
│  1. 仕様を書く（SPECIFICATION.md） │
└──────────────┬──────────────────────┘
               ↓
┌──────────────────────────────────────┐
│  2. テストを書く（失敗するテスト）  │ ← Red
└──────────────┬───────────────────────┘
               ↓
┌──────────────────────────────────┐
│  3. 実装する（テストを通す）    │ ← Green
└──────────────┬───────────────────┘
               ↓
┌──────────────────────────────┐
│  4. リファクタリングする    │ ← Refactor
└──────────────┬───────────────┘
               ↓
      テストが通っているか？
               ↓
          [次の機能へ]
```

### ドキュメント記載内容

#### SPECIFICATION.md（仕様書）

```markdown
# {パターン名} 仕様書

## 1. 要件定義

### 1.1 機能要件
- [ ] 要件1
- [ ] 要件2

### 1.2 非機能要件
- **パフォーマンス**: レスポンスタイム < 100ms
- **スケーラビリティ**: 同時接続数 > 100
- **可用性**: 99.9%以上
- **セキュリティ**: [セキュリティ要件]

## 2. アーキテクチャ設計

### 2.1 システム構成
[構成図またはテキストで説明]

### 2.2 コンポーネント設計
- **コンポーネントA**: 役割と責務
- **コンポーネントB**: 役割と責務

### 2.3 技術スタック
- Python 3.13
- [使用するライブラリ]

## 3. API仕様

### 3.1 エンドポイント
| Method | Path | Description |
|--------|------|-------------|
| POST   | /predict | 推論実行 |

### 3.2 リクエスト/レスポンス形式
[詳細なスキーマ]

### 3.3 エラーレスポンス
[エラーコードとメッセージ]

## 4. データモデル

### 4.1 入力データ
[スキーマ定義]

### 4.2 出力データ
[スキーマ定義]

## 5. 成功基準

- [ ] 全テストケースがパス
- [ ] パフォーマンス要件を満たす
- [ ] エラーハンドリングが適切
- [ ] ログが適切に出力される
```

#### README.md（実装ドキュメント）

```markdown
# {パターン名}

## 概要
このパターンの目的と解決する課題

## アーキテクチャ
システム構成図や説明

## セットアップ
環境構築手順

## 実行方法
実際の実行コマンドとその説明

## テスト
テストの実行方法

## 学んだこと
実装を通して得た知見

## 参考
- [SPECIFICATION.md](./SPECIFICATION.md)
- [元のコード](../../../reference/...)
```

---

## 🔧 実装時の注意事項

### セキュリティ

- **機密情報**: API キー、パスワード等は環境変数で管理
- **`.gitignore`**: `.env`, `*.pem`, `*.key` 等を必ず追加
- **依存関係**: セキュリティ脆弱性のあるパッケージを避ける
- **入力検証**: 外部からの入力は必ず検証・サニタイズ

### パフォーマンス

- **リソース管理**: メモリリーク、ファイルディスクリプタのクローズ漏れに注意
- **非同期処理**: I/Oバウンドな処理は非同期化を検討
- **バッチサイズ**: メモリを考慮した適切なバッチサイズを設定
- **キャッシュ**: 計算コストの高い処理は適切にキャッシュ

### 機械学習特有の注意点

- **モデル管理**: モデルファイルのバージョン管理（DVC等の利用を検討）
- **再現性**: random seedの固定、環境の明示
- **データ**: サンプルデータはgitにコミットせず、ダウンロードスクリプトを用意
- **評価**: 学習と推論のメトリクスを明確に記録

---

## 🚀 開発ワークフロー

### 新しいパターンを実装する場合（仕様駆動 + TDD）

#### Step 1: プロジェクトセットアップ

```bash
# 1. ディレクトリを作成
mkdir -p my_implementations/ch{N}__{pattern_name}
cd my_implementations/ch{N}__{pattern_name}

# 2. テンプレートからpyproject.tomlをコピー
cp ../../templates/pyproject.toml.template pyproject.toml

# 3. Pythonバージョンを指定
echo "3.13" > .python-version

# 4. 仮想環境の作成
uv venv

# 5. 仮想環境の有効化
source .venv/bin/activate

# 6. 開発ツールのインストール
uv pip install pytest pytest-cov black ruff mypy

# 7. ディレクトリ構造を作成
mkdir -p tests src/{pattern_name}
touch src/{pattern_name}/__init__.py
touch tests/__init__.py
```

#### Step 2: 仕様策定（SDD）

```bash
# SPECIFICATION.mdを作成
# Claude Codeに「{パターン名}の仕様書を作成して」と依頼
```

仕様書には以下を含める：
- 要件定義（機能要件・非機能要件）
- アーキテクチャ設計
- API仕様
- データモデル
- 成功基準

#### Step 3: テスト作成（TDD - Red）

```bash
# テストファイルを作成
# Claude Codeに「仕様書に基づいてテストを作成して」と依頼
```

テストは仕様に基づいて作成：
- `tests/test_unit.py` - ユニットテスト
- `tests/test_integration.py` - 統合テスト
- `tests/test_e2e.py` - E2Eテスト（必要に応じて）

テストを実行して失敗することを確認：
```bash
pytest tests/ -v
# → テストが失敗する（Red）
```

#### Step 4: 実装（TDD - Green）

```bash
# Claude Codeに「テストを通すための実装を段階的に進めて」と依頼
```

最小限の実装から始めて、徐々に機能を追加：
1. 最初のテストを通す
2. 次のテストを通す
3. 繰り返し

各ステップでテストを実行：
```bash
pytest tests/ -v
# → テストが通る（Green）
```

#### Step 5: リファクタリング（TDD - Refactor）

```bash
# Claude Codeに「コードをレビューしてリファクタリング提案をして」と依頼
```

改善項目：
- コードの可読性
- 重複の削除
- 適切な抽象化
- パフォーマンス最適化

リファクタリング後にテストを実行：
```bash
pytest tests/ -v --cov=src
# → テストが通り、カバレッジを確認
```

#### Step 6: コード品質チェック

```bash
# フォーマット
black src/ tests/

# リント
ruff check src/ tests/

# 型チェック
mypy src/

# テスト実行（カバレッジ付き）
pytest tests/ -v --cov=src --cov-report=html
```

#### Step 7: ドキュメント作成と記録

```bash
# README.mdを作成
# progress/learning_log.mdに記録
```

### Claude Codeへの指示例

#### 良い指示（仕様駆動 + TDD）:

**フェーズ1: 理解**
- "synchronous_patternの参考コードを分析して、要件とアーキテクチャを説明して"
- "このパターンが解決する課題とユースケースを教えて"

**フェーズ2: 仕様策定**
- "同期推論パターンのSPECIFICATION.mdを作成して。要件定義から始めて"
- "API仕様を詳細に定義して。エンドポイント、入出力、エラーレスポンスを含めて"

**フェーズ3: テスト作成**
- "仕様書に基づいてユニットテストを作成して。まず失敗するテストから"
- "統合テストのテストケースを追加して"

**フェーズ4: 実装**
- "最初のテストを通すための最小限の実装をして"
- "次の機能を実装して、テストを段階的にGreenにして"

**フェーズ5: リファクタリング**
- "実装をレビューして、改善点を提案して"
- "パフォーマンスを最適化して、テストが通ることを確認して"

**フェーズ6: 検証**
- "実装したコードを実際に動かして動作確認して"
- "エラーケースのハンドリングを確認して"

#### 悪い指示：

- "参考コードをそのままコピーして" ← 学習にならない
- "全部一気に実装して" ← TDDサイクルを無視
- "テストは後で書く" ← テスト駆動開発ではない
- "仕様書は不要" ← 仕様駆動開発ではない

---

## 📊 進捗管理

### 必須タスク

- [ ] 各パターン学習開始時: `progress/learning_log.md` に開始日時を記録
- [ ] 実装完了時: チェックボックスにチェックを入れる
- [ ] 週次: 学習の振り返りと次週の計画を記載

### 推奨タスク

- 重要な発見や気づきは随時メモ
- 躓いた点とその解決方法を記録
- パターン間の関連性や組み合わせ方をメモ

---

## 🎓 学習の優先順位

### 推奨学習順序

1. **Chapter 2: Training** - 基礎となるモデル学習
2. **Chapter 3: Release Patterns** - モデルのリリース方法
3. **Chapter 4: Serving Patterns** - 推論サービスの実装（最重要）
4. **Chapter 5: Operations** - 運用とモニタリング
5. **Chapter 6: Operation Management** - 高度な運用管理

ただし、興味のある分野から始めてもOK。モチベーション維持が最優先。

---

## 🤝 Claude Codeとの協働ルール

### Claude Code に期待すること

1. **コード分析**: 参考コードの詳細な説明
2. **設計支援**: アーキテクチャの提案と議論
3. **実装サポート**: ゼロからのコーディング支援
4. **レビュー**: 実装したコードの改善提案
5. **トラブルシューティング**: エラーの解決支援
6. **ドキュメント作成**: README等の作成補助

### Claude Code が守るべきこと

1. **仕様駆動**: まず仕様を明確にし、それに基づいて開発を進める
2. **テスト駆動**: テストを先に書き、Red→Green→Refactorのサイクルを守る
3. **段階的実装**: 一度に全てを実装せず、小さなステップで進める
4. **説明**: コードだけでなく、なぜそう実装するのか説明する
5. **選択肢の提示**: 複数のアプローチがある場合は選択肢を示す
6. **学習重視**: 単にコードを書くだけでなく、理解を深める支援をする
7. **ベストプラクティス**: 本番環境を想定した品質のコードを書く
8. **実践的**: エラーハンドリング、ログ、モニタリングを含める
9. **Git操作の確認**: `git push` は実行前に必ずユーザーの確認を取る

---

## 🔌 外部ツール連携

このプロジェクトでは、以下の外部ツールをMCP (Model Context Protocol) 経由で利用できます：

- **GitHub MCP**: リポジトリ操作、Issue/PR管理
- **Notion MCP**: 学習記録の管理
- **Serena MCP**: 高度なコード分析・編集
- **Context7 MCP**: 最新ライブラリドキュメントの参照
- **PostgreSQL MCP**: データベース操作

詳細な設定方法は `notes/mcp_setup_guide.md` を参照してください。

---

## 📝 一時ファイルの管理ルール

### セッション関連の一時ファイル

プロジェクト進行中に作成される一時的なファイルは、セッション終了後に削除するかgitignoreに追加してください。

#### 一時ファイルの種類

1. **セッション記録ファイル**
   - `SESSION_*.txt` - セッション固有の作業記録
   - `PROJECT_STATUS.md` - その時点のプロジェクト状態
   - `QUICKSTART.md` - セッション固有のクイックスタートガイド
   - `RESTART_*.md` - セッション固有の再開手順

2. **一時的なガイドファイル**
   - セッション固有の手順書
   - 特定の問題解決のための一時ドキュメント

#### 管理方針

- **セッション終了時**: 一時ファイルを削除または整理
- **永続的な情報**: `notes/` または `progress/` に統合
- **.gitignore**: 一時ファイルのパターンを追加

```gitignore
# Session files (may contain tokens)
SESSION_*.txt
PROJECT_STATUS.md
QUICKSTART.md
RESTART_*.md
```

#### 判断基準

| ファイル | 保持 | 理由 |
|---------|------|------|
| 学習ガイド（汎用的） | ✅ | 今後も参照価値がある |
| セッション手順書 | ❌ | その時点の状況に特化 |
| 技術ドキュメント | ✅ | 永続的な知識 |
| ステータスファイル | ❌ | 時間経過で陳腐化 |

---

## 🔒 個人情報とセキュリティルール

### 個人情報の取り扱い

このプロジェクトは公開リポジトリとして運用されるため、個人情報の管理を徹底してください。

#### 禁止事項

以下の個人情報をコード、ドキュメント、コミットメッセージに含めないでください：

1. **実名**
   - フルネーム
   - 名前の一部（ファーストネーム、ラストネーム）

2. **連絡先情報**
   - メールアドレス（プライベート）
   - 電話番号
   - 住所

3. **システム固有情報**
   - ローカルマシンのユーザー名
   - ホスト名
   - 絶対パスに含まれる個人名

#### 推奨事項

**GitHubユーザー名を使用**:
- ドキュメントの作者名: `kshr123`
- Gitコミット設定:
  ```bash
  git config --global user.name "kshr123"
  git config --global user.email "kshr123@users.noreply.github.com"
  ```

**パス表記**:
```bash
# ❌ 個人情報を含む
/Users/tanaka_taro/Desktop/dev/ML_designpattern

# ✅ プレースホルダーを使用
/Users/kshr123/Desktop/dev/ML_designpattern
# または
/path/to/ML_designpattern
# または
~/Desktop/dev/ML_designpattern
```

**ドキュメントのメタデータ**:
```markdown
# ❌ 実名を含む
Author: Tanaka Taro
開発者: 田中太郎

# ✅ GitHubユーザー名を使用
Author: kshr123
開発者: kshr123
```

### 機密情報の取り扱い

#### 管理が必要な情報

1. **APIキー・トークン**
   - GitHub Personal Access Token
   - Notion Integration Token
   - その他のAPI認証情報

2. **環境変数**
   - データベース接続情報
   - サービスの認証情報

3. **秘密鍵**
   - SSH秘密鍵
   - 暗号化キー
   - 証明書

#### 安全な管理方法

**環境変数ファイル**:
```bash
# .env ファイルを使用（gitignore必須）
GITHUB_TOKEN=your_token_here
NOTION_TOKEN=your_notion_token
DATABASE_URL=postgresql://user:pass@localhost/db
```

**サンプルファイルの提供**:
```bash
# .env.example をリポジトリにコミット
GITHUB_TOKEN=your_token_here
NOTION_TOKEN=your_notion_token
DATABASE_URL=postgresql://localhost/postgres
```

**.gitignoreの設定**:
```gitignore
# Secrets
*.pem
*.key
credentials.json
secrets.yaml

# MCP Configuration (contains API tokens)
.mcp.json
.claude/settings.local.json

# Environment variables
.env
.env.local
.env.*.local
```

### Git履歴のクリーンアップ

もし個人情報や機密情報をコミットしてしまった場合：

**最新コミットのみの場合**:
```bash
# ファイルを削除してコミットを修正
git rm <sensitive-file>
git commit --amend --no-edit
git push --force
```

**履歴全体から削除する場合**:
```bash
# filter-branchで履歴を書き換え
git filter-branch --env-filter '
OLD_EMAIL="personal@email.com"
CORRECT_NAME="kshr123"
CORRECT_EMAIL="kshr123@users.noreply.github.com"

if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$CORRECT_NAME"
    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$CORRECT_NAME"
    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
fi
' --tag-name-filter cat -- --branches --tags

# 強制プッシュ
git push --force
```

**注意**: 強制プッシュは共同作業者に影響を与えるため、個人プロジェクトでのみ実施してください。

### GitHub Push Protectionについて

GitHubは自動的にトークンやシークレットの検出を行います：
- プッシュ時に機密情報を検出すると自動的にブロック
- 検出されたら該当ファイルを削除してから再プッシュ
- `.gitignore`を適切に設定して予防

---

## 🔄 このファイルの更新

このルールファイルは学習の進捗に応じて更新してください：
- 新しいベストプラクティスを発見したら追加
- 不要なルールは削除
- プロジェクトの方向性が変わったら反映

最終更新: 2025-11-04
- プロジェクト全体のルールと開発プロセスを整理
- 一時ファイル管理ルールを追加
- 個人情報とセキュリティルールを追加
- Git push前の確認ルールを追加
- MCP設定の詳細は notes/mcp_setup_guide.md に分離
